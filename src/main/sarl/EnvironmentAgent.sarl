import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import tx52.environment.DynamicObject
import tx52.environment.Environment
import tx52.environment.EnvironmentListener
import tx52.environment.EnvironmentObject
import tx52.environment.StaticObject

/**
 * @author Olivier
 * 
 */
agent EnvironmentAgent { //TODO récupérer le code d'IA54 et l'adapter
	
	uses Logging
	uses DefaultContextInteractions
	var environment : Environment
	var listeners = <EnvironmentListener>newArrayList
	var time = 0.0f
//	val actions = <environmentChangeQuery>newLinkedList
	
	on Initialize{
		println("\nTest")
		
		//we create the environment
		environment = new Environment()
		
		//we create the objects
		var objects = <EnvironmentObject>newArrayList(new StaticObject(2,2,1,1,null,environment.getjBoxWorld))
		objects.add(new StaticObject(10,10,5,5,null,environment.getjBoxWorld))
		for(var f=20;f<90;f+=5){
			objects.add(new DynamicObject(f,f,2,2,null,environment.getjBoxWorld))// null in UUID field indicate that the body isn't created by his agent
		}
		environment.addObjectToWorld(objects)
		
		/*we create the agent and they will create their body ?
		* I'm not sure about this because an agent cannot access the world. In this case they should ask for the creation of they body
		* maybe it's easier to create the body and the agent separately and then, link them.
		*/
		
		//fireEnvironmentChange
		
		environment.printMap()
		emit(new RunBeginingOfStep)
		environment.printMap()
	}
	
/*	def fireEnvironmentChange {
		var objects = new TreeMap<Point,EnvironmentObject>
		for (obj : getEnvironmentObjects) {
				objects.put(obj.position,obj)
		}
		var ^event = new EnvironmentEvent (ID, this.time, mapWidth, mapHeight, Collections::unmodifiableMap(objects))
		for (listener : this.listeners) {
			listener.EnvironmentChanged(^event)
		}
	}*/
	/**Pas ici???????? */
	def getEnvironmentObjects() { //only for fireEnvironmentChanged ?
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}

	//initialize the turn (update world state, give perceptions to AI, fire all the agents, *increase time) *or in endOfStep 
	on RunBeginingOfStep {
		
		//TODO write RunBeginingOfStep
		
		//test
		environment.runJBox(); //1 step of simulation
		
		synchronized(this){
			
		}
	}
	// update world state, update the position of all objects, move to next step
	on RunEndOfStep {
		//TODO write RunBeginingOfStep
		synchronized(this) {
			
		}
	}
	def fireGameOver {
		for (listener : this.listeners) {
			listener.gameOver()
		}
	}
}